<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Diamond Dashboard</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <link type="text/css" rel="stylesheet" href="styles/main.css">

        <script type="module" src="src/main.js"></script>
    </head>
    <body>
        <div id="scene-container">
            
        </div>

        <script type="module">

            import * as THREE from './vendor/three/build/three.module.js';

            import { OrbitControls } from './vendor/three/examples/jsm/controls/OrbitControls.js';
            import { GUI } from './vendor/three/examples/jsm/libs/dat.gui.module.js';

            let camera, scene, renderer;
            let plane;
            let pointer, raycaster, isShiftDown = false;

            let rollOverMesh, rollOverMaterial;
            let cubeGeo, cubeMaterial;

            var aCube = {};
            var selected;

            const objects = [];

            init();
            render();

            function init() {

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.set( 500, 800, 1300 );
                camera.lookAt( 0, 0, 0 );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xf0f0f0 );

                // roll-over helpers

                const rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
                rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0x949494, opacity: 0.5, transparent: true } );
                rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
                scene.add( rollOverMesh );

                // cubes

                cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
                cubeMaterial = new THREE.MeshLambertMaterial( { color: 0x0ae8f0, map: new THREE.TextureLoader().load( 'assets/textures/square-outline-textured.png' ) } );

                // make fake selected cube for gui
                aCube.position = 0;

                // grid
                const gridHelper = new THREE.GridHelper( 1000, 20 );
                scene.add( gridHelper );


                raycaster = new THREE.Raycaster();
                pointer = new THREE.Vector2();

                const geometry = new THREE.PlaneGeometry( 1000, 1000 );
                geometry.rotateX( - Math.PI / 2 );

                plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
                scene.add( plane );

                objects.push( plane );

                // lights

                const ambientLight = new THREE.AmbientLight( 0x606060 );
                scene.add( ambientLight );

                const directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
                scene.add( directionalLight );

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // GUI

                const gui = new GUI();
                gui.add(aCube, 'position', 0, 100).onChange(function (e) {
                    selected.position.y = e;
                });
                // gui.add( params, 'addPoint' );
                // gui.add( params, 'removePoint' );
                gui.open();

                 // Controls
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.damping = 0.2;
                controls.addEventListener( 'change', render );

                document.addEventListener( 'pointermove', onPointerMove );
                document.addEventListener( 'pointerdown', onPointerDown );
                document.addEventListener( 'keydown', onDocumentKeyDown );
                document.addEventListener( 'keyup', onDocumentKeyUp );

                window.addEventListener( 'resize', onWindowResize );

            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function onPointerMove( event ) {
                pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
                raycaster.setFromCamera( pointer, camera );

                const intersects = raycaster.intersectObjects( objects );
                if ( intersects.length > 0 ) {
                    const intersect = intersects[ 0 ];

                    rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
                    rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
                }

                render();
            }

            function onPointerDown( event ) {
                pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
                raycaster.setFromCamera( pointer, camera );

                const intersects = raycaster.intersectObjects( objects );
                if ( intersects.length > 0 ) {
                     const intersect = intersects[ 0 ];

                    // delete cube
                    if ( isShiftDown ) {
                        if ( intersect.object !== plane ) {
                            scene.remove( intersect.object );
                            objects.splice( objects.indexOf( intersect.object ), 1 );
                        }

                    } else {
                        // if selecting existing cube
                        if ((intersect.object instanceof THREE.Mesh) && 
                            (intersect.object !== plane)) {
                            selected = intersect.object;
                        }
                        else {
                        // creating cube
                        const voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
                        voxel.position.copy( intersect.point ).add( intersect.face.normal );
                        voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
                        // voxel.position.y = 75;
                        scene.add( voxel );

                        objects.push( voxel );
                    }

                    }

                    render();

                }

            }

            function onDocumentKeyDown( event ) {
                switch ( event.keyCode ) {
                    case 16: isShiftDown = true; break;
                }
            }

            function onDocumentKeyUp( event ) {
                switch ( event.keyCode ) {
                    case 16: isShiftDown = false; break;
                }
            }

            function render() {
                renderer.render( scene, camera );
            }

        </script>

    </body>
</html>